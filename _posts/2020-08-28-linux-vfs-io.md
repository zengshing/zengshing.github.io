---
layout:     post
title:      "Linux 文件系统是怎么工作的"
subtitle:   "[Linux] 理论篇，了解VFS结构以及IO类型"
date:       2020-08-28 18:00:00
author:     "StevenZ"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - Linux
---



## 文件数据到底是怎么存储的呢？是不是直接写到磁盘中呢？

>   在了解文件系统的概念前，我们先了解下文件是如何存储到磁盘中的。

总所周知，文件是保存到存储的， 那硬盘的最小存储单位叫做"扇区"（Sector），每个扇区储存512字节（相当于0.5KB）。

操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个"块"（block）。<u>这种由多个扇区组成的"块"，是文件存取的最小单位。</u>"块"的大小，最常见的是4KB，即连续八个sector组成一个block。

## 索引节点和目录项

>   你要记住最重要的一点，在 Linux 中一切皆文件。不仅普通的文件和目录，就连块设备、套接字、管道等，也都要通过统一的文件系统来管理。

-   索引节点

    简称为 inode，用来记录文件的元数据，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。**索引节点和文件一一对应**，它跟文件内容一样，都会被持久化存储到磁盘中。所以记住，<u>索引节点同样占用磁盘空间。</u>([为什么linux空间不够，但是df显示有空间？](https://www.cnblogs.com/kevingrace/p/5577201.html))

    ```
        　　* 文件的字节数
        　　* 文件拥有者的User ID
        　　* 文件的Group ID
        　　* 文件的读、写、执行权限
        　　* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。
        　　* 链接数，即有多少文件名指向这个inode
        　　* 文件数据block的位置
    ```
    
    
    
-   目录项

    简称为 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的关联关系。多个关联的目录项，就构成了文件系统的目录结构。不过，不同于索引节点，目录项是由内核维护的一个内存数据结构，所以<u>通常也被叫做目录项缓存</u>。

    >   为什么需要dentry？
    >
    >     dentry（directory entry）是一个存放在内存里的缩略版的磁盘文件系统目录树结构，假设不存在dentry这个数据结构，那么就不得不每次都需要去查inode和文件名的关系。
    >
    >   比如查/etc/hosts文件：
    >
    >   1.  首先需要去根目录／所在的inode找到根目录／的数据块，从根目录／的数据块中读取到etc这个条目的inode；
    >
    >   2.  跳转到etc的inode，再查找inode指向的数据块，读取到/etc 目录的内容，从中读取hosts文件内容 



换句话说，索引节点是每个文件的唯一标志，而目录项维护的正是文件系统的树状结构。<u>目录项和索引节点的关系是多对一，你可以简单理解为，一个文件可以有多个别名。</u>

就如硬链接一样， 通过硬链接为文件创建的别名，就会对应不同的目录项，不过这些目录项本质上还是链接同一个文件，所以，它们的索引节点相同。

![image-20200827171950772](https://raw.githubusercontent.com/zengshing/note_images/master/img/image-20200827171950772.png)

下面是目录项、索引节点以及文件数据关系图：

![目录项、索引节点以及文件数据](https://raw.githubusercontent.com/zengshing/note_images/master/img/328d942a38230a973f11bae67307be47.png)

不过，这里有两点需要你注意。

第一，目录项本身就是一个内存缓存，而索引节点则是存储在磁盘中的数据。在前面的 Buffer 和 Cache 原理中，我曾经提到过，为了协调慢速磁盘与快速 CPU 的性能差异，文件内容会缓存到页缓存 Cache 中。 所以inode和dentry都会缓存到内存中，加速文件的访问 **[（思考： dentry是为加速访问inode，为什么inode还需要缓存到内存？）](https://unix.stackexchange.com/questions/334252/why-is-the-inode-cache-needed)**

第二，磁盘在执行文件系统格式化时，会被分成三个存储区域，超级块、索引节点区和数据块区。其中，

-   超级块，存储整个文件系统的状态。
-   索引节点区，用来存储索引节点。
-   逻辑数据块区，则用来存储文件数据。

>   superblock是文件系统的metadata，保存了文件系统的各种信息以及可以对其执行的操作。如索引节点和逻辑块的使用情况等。 <u>与索引节点和逻辑块一样，都是存储在磁盘中的。</u>

## 虚拟文件系统

>   目录项、索引节点、逻辑块以及超级块，构成了 Linux 文件系统的四大基本要素。为了支持各种不同的文件系统，Linux 内核在用户进程和文件系统的中间，又引入了一个抽象层，也就是虚拟文件系统 VFS（Virtual File System）。



VFS 定义了一组所有文件系统都支持的数据结构和标准接口。

用户进程和内核中的其他子系统调用VFS的接口进行交互，不需要关心底层实现。

![文件系统架构图](https://raw.githubusercontent.com/zengshing/note_images/master/img/728b7b39252a1e23a7a223cdf4aa1612.png)

在 VFS 的下方，Linux 支持各种各样的文件系统。按照存储位置的不同，这些文件系统可以分为四类。

-   第一类是基于磁盘的文件系统， 即DAS，常见的 Ext4、XFS、OverlayFS 等
-   第二类是基于内存的文件系统，就是我们常说的虚拟文件系统。这类文件系统，不需要任何磁盘分配存储空间，但会占用内存。如 /proc ， /sys 
-   第三类是网络文件系统，即NAS，比如 NFS、SMBI等。
-   第四类是网络存储协议， 即SAN， 如FC， iscsi等。

<u>使用文件系统都需要先挂载到VFS目录树下的某个子目录（挂载点）</u>。比如系统安装需要指定磁盘进行格式化， 格式化时选择文件系统类型，以及挂载点 ，默认是根目录/。 然后其他文件系统都需要挂载到根目录/下的挂载点才能被访问。

## 文件系统I/O

>   把文件系统挂载到挂载点后，你就能通过挂载点，再去访问它管理的文件了。

### 1. 缓冲与直接 I/O

-   缓冲 I/O（Buffer I/O），又被称作标准I/O, 是指利用标准库缓存来加速文件的访问，在文件读写时，先要经过系统的页缓存，然后再由内核或额外的系统调用，真正读写磁盘。

    >   全缓存I/O、行缓存I/O
    >
    >   这里所说的“缓冲”，是指标准库内部实现的缓存。比方说，你可能见到过，很多程序遇到换行时才真正输出，而换行前的内容，其实是被标准库暂时缓存了起来， 这就是行缓存I/O。

-   直接 I/O（Direct I/O），是指跳过操作系统的页缓存，直接跟文件系统交互来访问文件。**（与非缓存I/O相同）**

无论缓冲 I/O 还是直接 I/O，它们最终还是要经过系统调用来访问文件。而我们知道，系统调用后，还会通过页缓存，来减少磁盘的 I/O 操作。

想要实现直接 I/O，需要你在系统调用中，指定 O_DIRECT 标志。如果没有设置过，默认的是标准 I/O。不过要注意，直接 I/O、缓存 I/O，本质上还是和文件系统交互。

如果是在数据库等场景中，你还会看到，跳过文件系统读写磁盘的情况，也就是我们通常所说的裸 I/O。

>   内存映射文件（mmap）： 解决了用户进程可以直接访问也缓存数据，减少了用户地址空间向内核空间拷贝数据的CPU消耗。

下面这幅图加深概念理解：

![IO逻辑图](https://raw.githubusercontent.com/zengshing/note_images/master/img/20190320001938378.png)

### 2. 阻塞与非阻塞 I/O

-   阻塞 I/O，是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程，自然就不能执行其他任务。
-   非阻塞 I/O，是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过轮询或者事件通知的形式，获取调用的结果。

比方说，访问管道或者网络套接字时，设置 O_NONBLOCK 标志，就表示用非阻塞方式访问；而如果不做任何设置，默认的就是阻塞访问。

### 3.  同步与异步 I/O

-   同步 I/O，是指应用程序执行 I/O 操作后，要一直等到整个 I/O 完成后，才能获得 I/O 响应。
-   异步 I/O，是指应用程序执行 I/O 操作后，不用等待完成和完成后的响应，而是继续执行就可以。等到这次 I/O 完成后，<u>响应会用事件通知的方式</u>，告诉应用程序。

举个例子，在操作文件时，如果你设置了 O_SYNC 或者 O_DSYNC 标志，就代表同步 I/O。如果设置了 O_DSYNC，就要等文件数据写入磁盘后，才能返回；

而 O_SYNC，则是在 O_DSYNC 基础上，要求文件元数据也要写入磁盘后，才能返回。再比如，在访问管道或者网络套接字时，设置了 O_ASYNC 选项后，相应的 I/O 就是异步 I/O。这样，内核会再通过 SIGIO 或者 SIGPOLL，来通知进程文件是否可读写。

你可能发现了，这里的好多概念也经常出现在网络编程中。比如非阻塞 I/O，通常会跟 select/poll 配合，用在网络套接字的 I/O 中。

### 其他I/O场景的思考

>   举个老王煮水的例子：

1.  同步阻塞： 老王用水壶煮水，并且站在那里，不管水开没开，每隔一定时间看看水开了没。
2.  同步非阻塞：老王还是用水壶煮水，不再傻傻的站在那里看水开，跑去寝室上网，但是还是会每隔一段时间过来看看水开了没有，水没有开就走人。
3.  异步阻塞：老王这次使用高大上的响水壶来煮水，站在那里，但是不会再每隔一段时间去看水开，而是等水开了，水壶会自动的通知他。
4.  异步非阻塞： 老王还是使用响水壶煮水，跑到客厅上网去，等着响水壶自己把水煮熟了以后通知他。

其实，这两者存在本质的区别就是它们的修饰对象是不同的。阻塞和非阻塞是指进程访问的数据如果尚未就绪，进程应该怎么办？ 直接返回还是继续等待？ 而同步和异步是指要如何确认I/O是否完成，并获得响应， 是主动发现还是等待通知？

其实还有其他的IO类型， 这里待补充吧。



[1] [VFS中的file，dentry和inode](https://bean-li.github.io/vfs-inode-dentry/)

[2] [阮一峰-理解inode](https://www.ruanyifeng.com/blog/2011/12/inode.html)

[3] [[What is a Superblock, Inode, Dentry and a File?]](https://unix.stackexchange.com/questions/4402/what-is-a-superblock-inode-dentry-and-a-file)

[4] [从文件 I/O 看 Linux 的虚拟文件系统](https://www.ibm.com/developerworks/cn/linux/l-cn-vfs/)

[5] [Linux 中直接 I/O 机制的介绍](https://www.ibm.com/developerworks/cn/linux/l-cn-directio/)

[6] [阻塞和非阻塞、同步和异步 、五种IO模型](https://blog.csdn.net/qq_33314107/article/details/80766381)